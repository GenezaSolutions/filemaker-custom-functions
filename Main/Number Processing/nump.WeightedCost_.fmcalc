// nump.WeightedCost_ ( _qty_list; _cost_list; _last_cost; _qty_needed )
//
// Purpose:		The recursive portion of nump.WeightedCost
//
// Parameters:		_qty_list: 		The quantities that exist for each cost
//              		_cost_list:		The costs that we can draw from
//				_last_cost:		The last cost to use if we run out of quantity
//				_qty_needed:	The quantity needed to fulfill
//
// Requirements: 	requirements
//
// Author:			Charles Ross
// Version:		1.0 written 15-03-06
//
// Notes:			See notes on wrapper function appl.WeightedCost for further documentation.
//
// Example:
// // See example for nump.WeightedCost function.

Case (
  _qty_needed = 0;			// We got everything we needed
  devp.Nil;

  ValueCount ( _qty_list ) = 0;	// There wasn't enough to get what we needed.
  Let ( [
    $_wc_qty_used_list	= lsts.Append ( $_wc_qty_used_list;	_qty_needed );
    $_wc_cost_used_list	= lsts.Append ( $_wc_cost_used_list;	_last_cost )
  ]; devp.Nil );

  // Pop off the first item on the lists and push them onto the result list using the appropriate quantity.
  Let (
    [
      _avail_qty	= lsts.First ( _qty_list );
      _rest_qty	= lsts.Rest ( _qty_list );
      _curr_cost	= lsts.First ( _cost_list );
      _rest_cost	= lsts.Rest ( _cost_list );

      _taken_qty = Min ( _qty_needed; _avail_qty );

      $_wc_qty_used_list	= lsts.Append ( $_wc_qty_used_list;	_taken_qty );
      $_wc_cost_used_list	= lsts.Append ( $_wc_cost_used_list;	_curr_cost );

      _still_needed = _qty_needed - _taken_qty
    ];

    // Call again with updated lists and quantity needed.
    nump.WeightedCost_ ( _rest_qty; _rest_cost; _last_cost; _still_needed )
  )
)
