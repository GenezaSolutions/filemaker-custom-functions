// devp.UUID ( _version; _hyphenate )
//
// Purpose:		Generate a Universally Unique Identifier (UUID)
//
// Parameters:		_version:		Which version to use, 1 or 4
//              		_hypthenate:	Should hyphenation be used to separate sctions
//
// Requirements: 	nump.IntegerToHex
//
// Author:			Tom Robinson <http://www.tomrobinson.co.nz/>
// Version:		1.4 written 10-05-12
//
// Notes:			Version 1 UUIDs are based on the current timestamp and MAC address and are in the
//				form xxxxxxxx-xxxx-1xxx-yxxx-xxxxxxxxxxxx, where x is 0–F and y is 8–B. e.g.
//				7f23c000-b6fa-11ad-802a-136a8c2f7100.
//
//				Version 4 UUIDs are randomly generated and in the form
//				xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
//				e.g. f47ac10b-58cc-4372-a567-0e02b2c3d479.
//
//				The advantages of using a UUID over a serial number is there’s no need to worry
//				about the next value of a serial number or a serial number collision, forinstance
//				when importing records.  The downside is they’re not appropriate to expose to a user.
//
//				UUID example:  Dick and Harry both create records in their own copies of a database.
//				Each record needs a unique serial number so they can be combined at a later date.
//				After a total of 68,719,476,736 (2^36) records are created the probability of a collision
//				is 0.0000000000000004 (4 × 10^−16)
//
//				Further reading:  <http://en.wikipedia.org/wiki/UUID>
//
//				Caveats:
//				- Because FileMaker’s clock resolution is only in seconds the version 1 UUID can return
//					duplicates if called multiple times a second (there’s a 14-bit random number
//					included which usually prevents this).
//				- FileMaker 8.5–10.0v2 (and maybe earlier) have a bug where on some machines the
//					random function returns the same sequence of random numbers every time
//					FileMaker is restarted!  This obviously corrupts the generation of unique
//					identifiers.  Using a version 1 UUID is safer in this instance.  10.0v3 fixes this.
//				- I *think* I have the version 1 UUIDs correctly following the spec.  Note they include
//					local time (not UTC) and clock sequence is always random—both allowed but not
//					recommended.
//
// Example:
// // Every call will be different, but an example is...
// devp.UUID ( 1; True ) = "a2507280-cc62-11e4-b683-c8bcc8a2b3f0"

Let(
  [
    // Subtract to move timestamp epoch from 0001-01-01T00:00:00 to 1582-10-15T00:00:00, multiply
    //   to get from seconds to hundred-nanosecond intervals */
    _timestamp = nump.IntegerToHex ( ( Get( CurrentTimeStamp ) - 49916304000 ) * 10000000 );
    
    _rand_char = Middle( "89abb"; Random * 4 + 1; 1 );

    // Version 1
    _time_low	= Right( _timestamp; 8 );
    _time_mid	= Middle( _timestamp; 4; 4 );
    _time_hi	= "1" & Left( _timestamp; 3 );

    _rand = _rand_char & Right( "00" & nump.IntegerToHex( Random * 4096 ); 3 );

    _node = Substitute( GetValue( Get( SystemNICAddress ); 1 ); ":" ; devp.Nil );

    _version_1 = List (
      _time_low;
      _time_mid;
      _time_hi;
      _rand;
      _node
    );

    // Version 4
    _sect_1 = Right( "0000000"  & nump.IntegerToHex( Random * 4294967296 ); 8 );
    _sect_2 = Right( "000"      & nump.IntegerToHex( Random * 65536 ); 4 );
    _sect_3 = "4" & Right( "00" & nump.IntegerToHex( Random * 4096 ); 3 );
    _sect_4 = _rand_char & Right( "00" & nump.IntegerToHex( Random * 4096 ); 3 );
    _sect_5 = Right( "00000"    & nump.IntegerToHex( Random * 16777216 ); 6 ) &
      Right( "00000"  & nump.IntegerToHex( Random * 16777216 ); 6 );

    _version_4 = List (
      _sect_1;
      _sect_2;
      _sect_3;
      _sect_4;
      _sect_5
    );

    _uuid = Lower ( Case (
      _version = 1;	_version_1;
				_version_4
    ) );

    _separator = Case (
      _hyphenate;	"-";
				devp.Nil
    );

    _uuid = Substitute ( _uuid; "¶"; _separator )
  ];
  
  _uuid
)
