Case (  // top top grand case - every action calls one of these cases - essentially this is the swiss army knife of List / Dict utils and conceals the complexity in 1 custom function to avoid too many funcs



/*  JSON Reader - converts JSON into our format  */

/*
_action = "JSON"
_value = _JSON
_i = _inString
_level = _objectStack

depends on syntactically correct JSON - see json.org

basic principle: iterate thru _JSON character by character, converting the syntax to mine... adjusting nest level accordingly, avoiding picking up irrelevant white space, removing "\" escape character in strings (and ignoring escaped double quotes)

Unix2Mac
\n => ¶
\r => ¶
\" => "

a comma interprets as two different syntax depending on if array or object - so i need to keep a stack of objects so i can recurse and 'know' what kind of object I'm in... OAOAOAAAO etc - also by counting O or A i can simply find out how deeply nested I am...


*/

_action = "Read_JSON" ;

Let ( [
_thisChar = Left ( _value ; 1 ) ;
_value = Right ( _value ; Length ( _value ) - 1 ) ;

// ESCAPED CHAR CASE
_escapedChar = If ( _i and ( _thisChar = "\\" ) ; Left ( _value ; 1 ) ) ;
_value = If ( not IsEmpty ( _escapedChar ) ; Right ( _value ; Length ( _value ) - 1 ) ; _value ) ;

_i = Case ( _thisChar = "\"" ; If ( _i ; 0 ; 1 ) ; _i ) ;

_newObjectStack = Case ( _i ; _level ; _thisChar = "{" ; _level & "O" ;  _thisChar = "[" ; _level & "A" ; (_thisChar = "]") or (_thisChar = "}") ; Left ( _level ; Length ( _level ) - 1 ) ; _level )
] ;


Case ( not IsEmpty ( _escapedChar ) ; Case ( _escapedChar = "n" ; "¶" ; _escapedChar = "r" ; "¶" ; _escapedChar = "\"" ; "\"" ) ;

_i ; Case ( _thisChar = "\"" ; json.Null ; (_thisChar = "|") or (_thisChar = ":") ; json.#Escape ( _thisChar ; PatternCount ( _newObjectStack ; "O" ) ; PatternCount ( _newObjectStack ; "A") ) ; _thisChar ) ; // if in string return appropriately escaped character

_thisChar = "\"" ; json.Null ;

// not in string so respond to structure characters appropriately

// ALERT structure has arrived
_newObjectStack ≠ _level ; 
   Case ( _thisChar = "{" ; json.#Escape ( "<:" ; PatternCount ( _level ; "O" ) ; json.Null ) ;
             _thisChar = "}" ; json.#Escape ( ":>" ; PatternCount ( _newObjectStack ; "O" ) ; json.Null ) ;
             _thisChar = "[" ; json.#Escape ( "<|-" ; json.Null ; PatternCount ( _level ; "A" ) ) ;
             _thisChar = "]" ; json.#Escape ( "|->" ; json.Null ; PatternCount ( _newObjectStack ; "A" ) )
    ) ; 

// handle COLON 
_thisChar = ":" ;  json.#Escape ( ":=" ; PatternCount ( _level ; "O" ) - 1 ; json.Null ) ;


// handle COMMA
_thisChar = "," ; Case ( Right ( _level ; 1 ) = "A" ; json.#Escape ( "|-" ; json.Null ; PatternCount ( _level ; "A" ) - 1 ) ; json.#Escape ( ":><:" ; PatternCount ( _level ; "O" ) - 1 ; json.Null ) ) ;

// number
Filter ( _thisChar ; "0123456789.e+-" )

) // end big case

/* & Let ( $bug_result = $bug_result & "¶¶_thisChar : " & _thisChar & "¶_i : " & _i & "¶_level :  " & _level & "¶_newObjectStack : " & _newObjectStack & "¶¶"; _ )  
*/
&

If (  Length ( _value )  ;  json.|Tool ( "Read_JSON" ; json.Null ; _newObjectStack ; _value ; _i ; json.Null ; json.Null  )  )

)  ;


/*   ***********   END of JSON reader  ***********  */








/*  PRINT FUNCTION  */
Left ( _action ; 5 ) = "print" ;

//=======PRINT=======
//|Tool ( _action ; _list ; _level ; _value ; _i ; _c ; _e ) = use _i as iteration point, and _c as total count, use _value as LENGTH - linebreak if > 100 ; _e is the type

Case ( _e = "list";  // sub case --------- LIST
Let ( [	
  _indent = json.Repeat ( "	" ; _level + 1 ) ;

  _s = Position ( _list ; "|-" ; 0 ; 1 ) ;
  _end = Position ( _list ; "|-" ; _s + 2 ; 1 ) ;
  _v = json.#Escape( Middle ( _list ; _s + 2 ; _end - _s - 2 ) ; json.Null ; -1);
  _rest = Middle ( _list ; _end ; Length ( _list ) ) ;
  _vType = json.#VarType ( _v ) ;
  _linebreak = If ( (_value > Case (_action = "PrintJSON"; 80 ; 40)) or (_vType = "list" ) or (_vType = "dict")  ; True ; False ) ;
/*
$$bug_result = $$bug_result & "List: " & _list & "¶Level: " & _level & "¶Value: " & _value & "¶_i: " & _i & "¶_c: " & _c & "¶_e: " & _e & "¶_v: " & _v & "¶¶¶"; */
  _vPrint = Case ( (_vType = "list") or (_vType = "dict"); json.|Tool ( _action ; _v ; _level + 1 ; Length ( _v ) ; 1 ; json.#Count ( _v  ) ; _vType ) ;
                      json.IsNumber ( _v ) ; _v ; Quote ( _v ) )
] ;


Case ( 
  _action = "PrintJSON" ;
  Case ( _c = 0 ; "[]" ; If (_i=1 ; "[" & If (_linebreak ; "¶" ; " ") ) & If (_linebreak ; _indent ) & _vPrint & Case ( _i < _c ; "," & If (_linebreak ; "¶" ; " " ) &json.|Tool ( _action ; _rest ; _level ; _value ; _i + 1 ; _c ; _e ) ; _i = _c ; If ( _linebreak ; "¶" &  Left ( _indent ; _level ) ; " " ) & "]")   ) ;

  _action = "Print" ;
  Case ( _c = 0 ; "[]" ; If (_i=1 ; "[" & If (_linebreak ; "¶" ) ) & If (_linebreak ; _indent ) & (_i-1) & "  =>  "  & _vPrint & Case ( _i < _c ; ", " & If (_linebreak ; "¶") &json.|Tool ( _action ; _rest ; _level ; _value ; _i + 1 ; _c ; _e ) ; _i = _c ; If ( _linebreak ; "¶" &  Left ( _indent ; _level ) ) & "]")   ) ;

  _indent & "[" & _i & "] => " & Case ( _vType = "list" ; "¶" & json.|Tool ( _action ; _v ; _level + 1 ; json.Null ; 1 ; _c; _e ) ;  Substitute ( _v ; "¶" ; "\¶") ) & 
  If ( _i < _c ; "¶" & json.|Tool ( _action ; _list ; _level ; json.Null ; _i + 1 ; _c ; _e ) )
) // end case
) // end let

;  // end sub case let ----------- END LIST

_e = "dict" ; // sub case ------------- DICT
Let ( [
_s = Position ( _list ; "<:" ; 0 ; 1 ) ;
_m = Position ( _list ; ":=" ; _s ; 1 ) ;
_end = Position ( _list ; ":>" ; _m ; 1 ) ;

_rest = Middle ( _list ; _end + 2 ; Length ( _list ) ) ;
_k = json.#Escape( Middle ( _list ; 3 ; _m - 3 ) ; -1 ; json.Null ) ;
_v = json.#Escape( Middle ( _list ; _m + 2 ; _end - _m - 2 ) ; -1 ; json.Null );
_vType = json.#VarType ( _v ) ;
_indent = json.Repeat ( "	" ; _level + 1 ) ;

_vPrint = Case ( _vType = "list" or _vType = "dict" ; json.|Tool ( _action ; _v ; _level + 1 ; Length ( _v ) ; 1 ; json.#Count ( _v ) ; _vType ) ;
                       json.IsNumber ( _v ) ; _v ; Quote ( _v ) )
] ;

Case (
 /* _action = "Print#" ;
  _indent & "# ( \"" & _k & "\" ; " & Case ( (_vType ="dict"); "¶" & #Tool ( _v ; _ ; _level + 1 ; "print" ; _value ) & "¶" & _indent & ")" ; "\"" & Substitute ( _v ; " ¶" ; "\¶") & "\" )" ) & If ( not IsEmpty ( _rest ) ; " & ¶" & #Tool ( _rest ; _ ; _level ; "print" ; _value )  );*/

// http://tools.ietf.org/html/rfc4627 JSON FORMAT
  _action = "PrintJSON" ; 
  If ( _i = 1 ; "{¶" ) & _indent & "\"" & _k & "\": " & _vPrint  & Case ( _i < _c ;  ",¶" &  json.|Tool ( _action ; _rest ; _level ; _value ; _i + 1 ; _c ; _e ) ; _i = _c ; "¶" & Left ( _indent ; _level ) & "}" ) ;

  _action = "Print" ; 
  If ( _i = 1 ; "{¶" ) & _indent & "\"" & _k & "\": " & _vPrint  & Case ( _i < _c ;  ",¶" &  json.|Tool ( _action ; _rest ; _level ; _value ; _i + 1 ; _c ; _e ) ; _i = _c ; "¶" & Left ( _indent ; _level ) & "}" ) 


)

) // ?? ----------- END DICT

) ;
//=======END  PRINT=======





// ACTION ZIP
_action = "ZIP" ;
/* _value is the count of lists to go through 
_c gets set to the max level depth */

Let ( [
_li = json.#Get ( _list ; _i ) ;
_v = json.#Get ( _li ; _level ) ;
_vType = json.#VarType ( _li ) ;
_c = If ( IsEmpty(_c) and (_vType = "list") ; json.#Count ( _li ) ; _c )
];


Case ( IsEmpty( _c ) ; json.Null ; // INVALID ZIP REQUEST
  ( (_level + 1) = _c ) and ( (_i + 1) = _value ) ; _v & "|->" ; // END OF ZIP REACHED 
  If( _i = 0 ; "<|-" ) & _v & "|-" & If ( ( _i + 1) = _value ; ">" ) & json.|Tool ( "ZIP" ; _list ; _level + If ( ( _i + 1) = _value ; 1 ) ; _value ; If ( ( _i +1 )< _value ; _i + 1 ; 0 ) ; _c ; json.Null )
 )
)
;
// END ACTION ZIP











// --- ACTION GET

_action = "get" ;
//     |Tool ( "GET" ; _dictOrList ; 1 ; _i ; _ ; COUNT ; _vType ) - _i{ndex} goes into _value (goes _i might be used for iterating thru _values
// to get this far it is already a valid list or dict, type stored in vType


// check 4 brackets

Let ( [
// remove brackets from first item... handle [1][2] as well as 1[2] or [dict][1] as well as dict[1]
_value = If ( Left ( Trim ( _value ) ; 1 ) = "[" ; Let ( [_pos1 = Position ( _value ; "[" ; 0 ; 1 ) ;
_pos2 = Position ( _value ; "]" ; _pos1 ; 1 ) ] ; Trim ( Middle ( _value ; _pos1 + 1 ; _pos2 - _pos1 -1 ) ) &  Trim ( Middle ( _value ; _pos2 + 1 ; Length ( _value ) ) ) ) ; _value ) ;
// end bracket handler!

_brackets_match = Position ( _value ; "[" ; 0 ; 1 ) and Exact ( PatternCount ( _value ; "[" ) ; PatternCount ( _value ; "]" ) ) 
//---------- basic error checking bit - r there brackets and do they match - if so this boy is a multi-dimensional
];


If ( _brackets_match ; 

Let ( [
_pos1 = Position ( _value ; "[" ; 0 ; 1 ) ;
_pos2 = Position ( _value ; "]" ; _pos1 ; 1 ) ;
_vCur = Trim ( Left ( _value ; _pos1 - 1 ) ) ;
_vCur_listOrDict = json.|Tool ( "GET" ; _list ; _level ; _vCur ; json.Null ; _c ; _e ) ;
_vType = json.#VarType ( _vCur_listOrDict ) ;
_result  = json.|Tool ( "GET" ; _vCur_listOrDict ; _level ; Trim ( Middle ( _value ; _pos1 + 1 ; _pos2 - _pos1 -1 ) ) &  Trim ( Middle ( _value ; _pos2 + 1 ; Length ( _value ) ) ); json.Null ; If ( _vType = "list" ; json.#Count ( _vCur_listOrDict ) ) ; _vType  ) 
] ;
_result ) ; // end let


// if not brackets match
// not multi-dimensional so get the value =>


Case ( 

IsEmpty ( _value ) ; // ERROR #Get ( a[] )
Let ( $cf_|Tool_error = "Error 7010: #Get without supplied index value" ; json.Null ) ;  


(_e = "list") and (Position(_value; ":"; 0 ; 1) ) ; // it's a SLICE SLICE SLICE
json.|Tool ( "SLICE_init" ; _list ; json.Null ; _value ; json.Null ; _c ; "get" ) ; 

// --------- LIST
_e = "list" ; 
Let ( [ _isInt = ( json.IsNumber (_value ) and ( Int(_value)=_value ) );
              _value = GetAsNumber ( _value ) ;
              _value = Case ( _value >= 0; _value + 1 ; (_value>(_c-1)) or (_value < (-1*_c)) ; json.Null ; _c + _value + 1 ) ; // convert negative to positive for sanity checking
              pstart = Position( _list; "|-" ; 0 ; _value) ;
              pend = Position( _list ; "|-" ; pstart + 2 ; 1 )
        ];/*Let ( $$bug_result = $$bug_result & "¶¶list: " & _list & "¶pstart: " & pstart  & "¶_value: " & _value & "¶_c: " & _c  & "¶_e: " & _e   ;_) & */

Case (
  // non integer index on list, i.e. a[1.5] or a[text] where a = [1,2,3] or [1.5,'text',frog]
  not _isInt ; Let ( $cf_|Tool_error = "Error 7011: #Get attempt on list with a non-integer..." ; json.Null ) ; 

  pstart and pend ;     json.#Escape ( Middle( _list; pstart + 2 ; pend - pstart - 2 )  ; json.Null ; -1 ) ;

  // out of range integer supplied
  Let ( $cf_|Tool_error = "Error 7012: #Get out of range"; json.Null ) 
)

) ;

// -------- DICT
_e = "dict" ;
Let( [           
              match="<:" & json.#Escape( _value ; 1 ; json.Null ) & ":=";
              pstart = Position(_list ; match; 0; 1);
              start = pstart + Length(match);
              end = Position(_list ; ":>"; start; 1);
              len = If(end = 0; 999999999; end - start)];



              If (  pstart = 0; ""; json.#Escape (  Middle(_list; start; len) ;  -1 ; json.Null )  )
) // end let

) // end case


) // end brackets match if


) ; // end Let
// END ACTION GET








// --------- SLICE
_action = "SLICE_init";
// _level, _e, _i contains the _info to replace it with; _c is count of list; _e is execute - coming from get - it has _get in it, coming from #set it has set...!
Let ( [
    _p1 = Position ( _value ; ":" ; 0 ; 1 ) ;
    _p2 = Position ( _value ; ":" ; _p1 + 1 ; 1 ) ;

// work out any defined original values b4 determining values to parse to sub-functions as usage does vary slightly, but significantly
   _oStride = If ( _p2 ; /* [start:end:X] */ GetAsNumber(Middle ( _value ; _p2 + 1 ; 999999 ))  ) ;
   _SEQ = _oStride ;
   _oStart = GetAsNumber(Case ( _p1 > 1 ; Left ( _value ; _p1 - 1 ) )) ;
   _oEnd = GetAsNumber(Case ( (_p2 - _p1 ) > 1 ; Middle ( _value ; _p1 + 1 ; _p2 - _p1 - 1 ) ; not _p2 /* only 1 long, i.e. [start::stride] */ ; Middle ( _value ; _p1 + 1 ; 9999999 ) ));

// define general defaults - can redefine on basis of _oRiginals in sends
    _stride = If ( _oStride ; _oStride ; 1 ) ; // stride cannot = zero ];

    _start = Case ( IsEmpty(_oStart) ; Case( _stride < 0 ; _c - 1 ; 0 ) ; _oStart >= 0; _oStart ; _oStart < 0 ; _c + _oStart ) ; // convert minus to positive equivalent for sake of SLICE maths
    _start = Case ( (_e = "insert") and not _SEQ ; Min( _Start ; _c ) ; (_start + 1) > _c ; _c - 1 ; _start < 0 ; 0 ; _start ) ; // fix start so it doesn't die outside of range needlessly (can still die, but a[10:4:-1] on a=[0,1,2,3,4,5,6] should return [6, 5], so this fixes it to [6:4:-1]
    _end = Case ( IsEmpty ( _oEnd ) ; Case ( _stride > 0 ; _c ; -1 ) ; _oEnd >= 0; _oEnd ; _oEnd < 0 ; _c + _oEnd ) ; // convert minus to positive for sake of SLICE maths
    _SeqL =  1+Div ( Min ( Max (_start ; _end ) ; _c ) - 1 - Min ( _start ; _end ) ; Abs(_stride) ) ;
    _thisOK = Case ( _e = "insert" and _SeqL = 0 ; 1; ( ((_end - _start )*_stride )> 0 )   ) ;   // NO NO NO to > 1:3:-1 or 3:1:1, yes yes yes to 3:1:-1  1:3:1 = 1  -- guarantees we have valid syntax
              

_result = If ( _thisOK ;
Case (
  _e = "get" ;  json.|List ( json.|Tool ( "SLICE_get"; _list ; _start ; json.Null ; _stride ; _SeqL ; json.Null )  ) ;
// 2 insert cases: SEQUENCE replace (the more picky  - must match in number ; SLICE replace )
  _e = "insert" ; Case ( 
           _SeqL = 0 ;  json.|Tool ( "SLICE_replace" ; _list ; _start ; _i ; 1 ; _c ; _end ) ; // proper insert
           _SEQ and (_SeqL = json.#Count ( _i ) ) ; json.|Tool ( "SLICE_set" ; _list ; _start ; _i ; _stride ; _SeqL ; 0 ) ; 
           _SEQ ; Let ( $cf_|Tool_error = "Error 7015: #Set Slice error - sequence size does not match"; json.Null ) ;
           not _SEQ and (_end > _start) ; json.|Tool ( "SLICE_replace" ; _list ; _start ; _i ; json.Null ; _c ; _end ) ; 
           not _SEQ ; Let ( $cf_|Tool_error = "Error 7016: #Set Slice error - invalid slice: [" & _start & ":" & _end & "]" ; json.Null ) 
           ) ;
  _e = "delete" ;  json.|Tool ( "SLICE_delete" ; _list ; If ( _stride< 0; _start ; _start + ( _SeqL * _stride ) - _stride ) ; json.Null ; Abs(_stride) ; _SeqL ; json.Null ) // weird code just ensures goes from bottom to top, makes it easy to remove items...
  ) ;  // else if not OK error to avoid mashing actual data
Let ( $cf_|Tool_error = "Error 7016: Slice error"; json.Null )
)

        ];
/* 
Let ( $$Bug_result = $$Bug_result & "¶¶_action: " & _action & "¶_list: " & _list & "¶_value: " & _value & "¶SEQ: " & _SEQ & "(length: " & _SeqL & ")¶_thisOK: " & _thisOK & "¶_oStart: " & _ostart &  "¶_start: " & _start & "   end: " & _end & "    stride: " & _stride & "¶_i: " & _i  & "¶_e: " & _e & "¶_c: " & _c ; _ ) &*/
If ( IsEmpty ( _result ) ; json.Null ; _result )

) // end let
;
// -------- END SLICE 

// --- SLICE_REPLACE - if more than one results in list
// |Tool ( _action ; _list ; _level = curPOS ; _value = replacement list ; _c = count of _list; _e = repace point end
_action = "SLICE_replace" ;
Let ( [
  _pos1 = Position ( _list ; "|-"; 0 ; _level + 1 ) ;
  _pos2 = If (   _i ; _pos1 ;     Position ( _list ; "|-" ; _pos1 + 2 ; If ( _e >(_c + 1) ; (_c + 1) ; _e ) - _level )   ) ]; 
  Left ( _list ; _pos1 + 1 ) & Middle ( _value ; 4 ; Length ( _value ) - 4 ) &  Middle ( _list ; If(_pos2; _pos2 + 2; Length(_list) ) ; Length(_list) )
) ;  // end let
// --- END SLICE_REPLACE

// --- SLICE_DELETE - if more than one results in list
// logic = do it from top to bottom - so max min to insure the order and abs(_stride)
// |Tool ( _action ; _list ; _level = curPOS ; _value = replacement values  ; _i = STRIDE ; _c = count of iterations to go; _e = current iteration in replacements
_action = "SLICE_delete" ;
Let (
  [_iterate = _c > 1 ;
   _pos1 = Position (_list ; "|-"; 0 ; _level + 1 ) ;
   _pos2 = Position ( _list ; "|-" ; _pos1 + 2 ; 1 ) ; 
   _list = Left ( _list ; _pos1 + 1 ) & Middle ( _list ; _pos2 + 2 ; Length(_list)) ];
   If ( _iterate ;   json.|Tool ( _action ; _list ; _level - _i ; json.Null ; _i ; _c - 1 ; json.Null ) ; _list )
) ;  // end let
// --- END SLICE_DELETE

// --- SLICE_GET - if more than one results in list
// |Tool ( _action ; _list ; _level = curPOS ; _i = STRIDE ; _c = count of iterations to go
_action = "SLICE_get" ; Let (   _iterate = _c > 1 ; json.#Get ( _list ; _level ) & If ( _iterate ;  json.… & json.|Tool ( _action ; _list ; _level + _i ; json.Null ; _i ; _c - 1 ; json.Null ) )   );
// --- END SLICE_GET


// --- SLICE_SET - if more than one results in list
// |Tool ( _action ; _list ; _level = curPOS ; _value = replacement values  ; _i = STRIDE ; _c = count of iterations to go; _e = current iteration in replacements
_action = "SLICE_set" ;
Let ( [_iterate = _c > 1 ; _list = json.#(_list & "[" & _level & "]" ; json.#Get ( _value ; _e ) )]; If ( _iterate ;   json.|Tool ( _action ; _list ; _level + _i ; _value ; _i ; _c - 1 ; _e + 1 ) ; _list ) ) ;
// --- END SLICE_SET












// ACTION COMP
_action = "COMP" ; 
/* ------- |Tool ( "COMP" ; _list ; 1 ; _varsVL ; |Count ( |Get ( _list ; 1 ) ) ; _cond; _expression )
i.e. on arrival:

_list = full list to go thru
_level = 0 if e is a list
_value = "x…y…" & |list ( z…w )  [var list]
_i = |Count ( |Get ( _list ; 1 ) )
_c = conditional statement (if any)
_e = expression to evaluate - already containing condition if necessary, and list split (from |Comp) 

it automatically puts results into a list as long as the for is deep, so everything is wrapped within |items ( row & … & row N )
but if expression has … in it then as many different calcs as list to be the result...
[ x, x*2 ] => |items ( x & … & (x*2) )

*/

// _c & _e NEVER CHANGE FROM OUTSET, SO SET IN |Comp ON AND PASS

Let ( [
_c = If (IsEmpty (_c) ; 1 ; _c );
_varList = json.|Tool ( "COMP_vars_in_list" ; json.#Get ( _list ; _level ) ; json.#VarType(_value) ; _value ; 0 ; json.Null ; json.Null ) ;

_evalStatement = "Let ( [" & _varlist & " ] ; " &
// only evaluate _e, if the _c{ondition} evaluates as true...
"  If ( " & _c & " ; " & _e & " & … ) "  & // end of if statement
")" // end of Let statement
] ;

Evaluate ( _evalStatement )
/* & Let ($$bug_result=$$bug_result & "¶¶>>>COMP: varList —" & _varList & "¶_evalStatement: " & _evalStatement & "¶¶"; _ )  */
)
& If ( (_level+1) < _i ; json.|Tool ( "COMP" ; _list ; _level + 1 ; _value ; _i ; _c  ; _e )  )
 ;
// END COMP



// COMP_expression 
// produces the expression within the Let statement body to evaluate... called once from |Comp
_action = "COMP_expression" ;

Case ( json.#VarType ( _e ) = "list" ; // _e is a list - iterate the mother
json.|Tool ( _action ; json.Null ; json.Null ; json.Null ; json.Null ; json.Null ; json.#Get ( _e ; _level ) ) & If ( (_level + 1) < _c ; " & … & " & json.|Tool ( _action ; json.Null ; _level + 1 ; json.Null ; json.Null ; _c ; _e ) ) ;
" ( " & _e & " ) " ) ;

// END COMP_expression




// ACTION COMP_vars_in_list - i is the variable count
 _action = "COMP_vars_in_list" ;

/* 
this is sent either a single variable, or a list of variables, or a nested list of variables,  which it then loops thru and assigns appropriate value in list too for use in Let statement building...

_c: CLEAR - sent as "clear"/1 if desire to produce and empty var list $var = "" etc to kill vars
_e is sent blank by |Comp, but |For uses this for variable setting, to add $ to front
_value is the count of list items to go through */

Case (
// if only one var being asked for then 1D (else 2D)
_level ≠ "list" ; _e & _value & " = " & If ( json.IsNumber ( _list ) ; _list ; Quote ( _list ) ) ;  

// is list - iterate thru it
Let ( [
_v = json.#Get ( _list ; _i ) ;
_var = json.#Get ( _value ; _i ) ;
_vExpression = Case ( (_c and json.#VarType(_var)="list") or (json.#VarType (_v) = "list") and (json.#VarType ( _var ) = "list") and (json.#Count(_v)=json.#Count(_var)); json.|Tool ( _action ; _v ; "list" ; _var ; 0 ; json.Null ; _e ) ;
                                 json.#VarType ( _var ) = "list" ; Let ( $cf_|Tool_error = "Error 7020: Expression expansion fail for iterating... List: " & _v & "¶¶Broke with the following variables expansion: " & _var ; json.Null ) ;  // FAIL
                                 "¶" & _e & _var & " = " & If ( json.IsNumber ( _v ) ; _v ; Quote ( _v ) )
                                )
  // quote prevents ¶/" breaking stuff which they do otherwise! - so valuelists and quoted items fail
];

Case (
   ( _i + 1 ) = json.#Count ( _value ) ; _vExpression ; // END OF COMP REACHED 
   _vExpression & " ; "  &  json.|Tool ( _action; _list ; _level ; _value ; 1+ _i ; json.Null ; _e)
 )


) // end let
) ; // end case
// END ACTION COMP_vars_in_list







// SET_UPDATE or SET_DELETE
Left ( _action ; 4 ) = "SET_";
/*

list or dict update...

find list or dict location - given a dict/list and key, return first and last char pos feasible level and key
	wot about SLICE? - a[1:5:2] = [3,1]  suggests work with whole array on fly not keep setting $
		|Tool ( "SLICE_set"... do slice at end - it will just call #( list ; _i) iteratively thru slice and return that, so basic must work first
		|Tool ( "SET_delete" ; …
		|Tool ( "SET_update" ; …
         they share almost everything except delete removes and set replaces/adds/creates, for sanity i will split by passed type (list or dict)
   _level = counter of dict nesting
   _i = INDEX / KEYS
   _c = count of list nesting
   _value = VALUE TO SET TO
for escaping and key finding purposes i will need to keep a count of levels for both...

LOGIC NOTES:

The behaviour is intended to fail if you try to...
  set a dict in a list or vice versa
  have any keys following a slice
  have a mismatching length in _value if you are using a slice sequence

///////  '_e' kept reserved against future use - commands such as pop etc could be easily added utilising it
  
#D passes: |Tool ( "SET_delete" ; _md_array ; 0 ; _ ; _keys ; 0 ; _ )
*/



// -------- KEY UPDATE ROUTINE - COMMON TO ALL
Let ( [
  _vType = json.#VarType ( _list ) ;
  _pek = Position ( _i ; "[" ; 0 ; 1 ) ; // Position End Key
  _pe2k = Position ( _i ; "]" ; 0 ; 1 ) ; // Position End 2nd Key
  _Key = If ( _pek ; Trim ( Left ( _i ; _pek - 1 ) ); Trim ( _i ) ) ;
  _rKeys = If( _pe2k ;  Trim ( Middle ( _i ; _pek + 1; _pe2k - _pek -1 ) ) & Middle (_i ; _pe2k+1; Length (_i) )   ) ; // REMAINING keys
  _slice = (_vType = "List") and Position ( _Key ; ":" ; 0 ; 1 ) ;
  _control = RightWords ( _action ; 1 ) ;
  _count = json.#Count ( _list ) ;
  _sqBracks = (_pek and _pe2k and IsEmpty (_rKeys)) ;
  _sqBracksCreate = (_sqBracks and (_control = "insert")) ;  // i.e. []
  _rKeys = If ( _sqBracksCreate ; " " ; _rKeys ) ; // to enable it to go to next level, this will get trimmed out & dissappear next level - ONLY case
  _eList = json.#Escape ( _list ; _level ; _c )  // return this if error and don't want to break  
];

// go to next stage

Case ( // MASTER CASE 4 SET_...


// sqBracks die
_sqBracks and not _sqBracksCreate ; Let ( $cf_|Tool_error = "Error 7001: illegal unspecified [] attempt" ; _eList) ;

// sqBracks a[dict][] or a[1][] - only if empty (i.e. most probably newly created) or list already, in which case goes on to end...
IsEmpty ( _Key ) and ((_vType = "empty") or (_vType = "list")) ; json.#Escape ( Case ( _vType = "empty" ; json.|List ( _value ) ; _vType = "list" ; Left ( _list ; Length(_list) - 1 ) & json.#Escape ( _value ; json.Null ; 1 ) & "|->" ) ; _level ; _c ) ;

// sq brackets but not allowed
IsEmpty ( _Key ) ; Let ( $cf_|Tool_error = "Error 7001: illegal unspecified [] attempt" ; _eList ) ;




_slice ; // ----------- SLICE IT UP

Case (
// an automatic failed SLICE cos stuff follows it, i.e. a[1:7:2][2]
not( IsEmpty (_rKeys)) ; Let ( $cf_|Tool_error = "Error 7002: set/delete slice attempt, but further keys/index found after slice" ; _eList  ) ;

(json.#VarType ( _value ) ≠ "list" ) and (_control = "insert"); Let ( $cf_|Tool_error = "Error 7003: set slice attempt, but value to set to is not list" ; _eList ) ;

// i need to send the entire _list to be modified appropriately by SLICE machine and returned as result, send the replacement slice info too
Let (
  _result = json.|Tool ( "SLICE_init" ; _list ; json.Null ; _key ; _value ; _count ; _control ) ;
  If ( IsEmpty($cf_|Tool_error) ; json.#Escape ( _result ; _level ; _c ) ; _eList )
)

 )
; // END SLICE




_vType = "LIST" ;

Let ( [
   _isInt = ( json.IsNumber (_key ) and ( Int(_key)=_key ) );
   _key = GetAsNumber ( _key ) ;
   _key = Case ( _key >= 0; _key + 1 ; (_key>(_count-1)) or (_key < (-1*_count)) ; json.Null ; _count + _key + 1 ) ; // convert negative to positive for sanity checking
   _pstart = Position( _list; "|-" ; 0 ; _key) ;
   _pend = Position( _list ; "|-" ; _pstart + 2 ; 1 ) ;

// left and right parts to send back unaltered
  _eL = json.#Escape (  Left ( _list ; _pstart + 1) ; _level ; _c ) ;
  _eR = json.#Escape ( Middle ( _list ; _pend ; Length(_list)  )  ; _level  ; _c ) ;
  _targetValue = If ( _pstart ; json.#Escape ( Middle( _list; _pstart + 2 ; _pend - _pstart - 2 )  ; json.Null ; -1 ) ) ;
  _targetType = json.#VarType ( _targetValue )
] ;

Case (
  // non integer index on list, i.e. a[1.5] or a[text] where a = [1,2,3] or [1.5,'text',frog]
  not _isInt ; Let ( $cf_|Tool_error = "Error 7004: #Set list attempt with a non-integer..." ; _eList ) ;

  // out of range integer supplied
  not (_pstart and _pend) ; Let ( $cf_|Tool_error = "Error 7005: #Set list out of range"; _eList ) ;

Case ( // control case split

_control = "delete" ; _eL & If ( IsEmpty ( _rKeys ) ; Middle ( _eR ; 3 ; Length (_eR)) ; json.|Tool ( _action ; _targetValue ; _level  ; json.Null ; _rKeys ; _c + 1 ; json.Null ) & _eR ) ;

_control = "insert" ; Case (
  IsEmpty ( _rKeys ) ; _eL & json.#Escape ( _value ; _level ; _c + 1 ) & _eR ;
  _eL & json.|Tool ( _action ; _targetValue ; _level  ; _value ; _rKeys ; _c + 1 ; json.Null ) & _eR )

)

)

) ; // end Let for LIST





_vType = "DICT" and IsEmpty ( _Key ) ; json.Null ; // return straight away, you can't have a dict with no name...
(_vType = "DICT") or ( _vType = "empty" );
Let ( [

  _startKey = "<:" & json.#Escape ( _Key ; 1 ; json.Null ) & ":=" ;
  _pstart = Position ( _list ; _startKey ; 0 ; 1  ) ;
  _pstart = If ( _pstart ; _pstart + Length ( _startKey ) ) ;
  _pend= If ( _pstart ;  Position ( _list ; ":>" ; _pstart ; 1  ) + 2 ) ;

// left and right parts to send back unaltered
  _eR = json.#Escape ( If ( _pstart ;  Middle ( _list ; _pend ; Length(_list)  ) ) ; _level  ; _c ) ;
  _eL = json.#Escape ( If ( _pstart ; Left ( _list ; _pstart - Length ( _startKey ) - 1 ) ;  Middle ( _list ; _pend ; Length(_list)  ) ) ; _level  ; _c ) ;

  _targetValue = If ( _pstart ; json.#Escape ( Middle ( _list ; _pstart ; _pend - _pstart - 2 ) ; -1 ; json.Null ) ) ;
  _targetType = json.#VarType ( _targetValue )
] ;


/*   BUG TESTING!!!  
Let ( $$bug_result = $$bug_result &
"¶¶Dict: " & _list & 
"¶Level: " & _level & 
"¶_c: " & _c &
"¶_i: " & _i & 
"¶This Key: " & _Key &
"¶Start Key: " & _startKey &
"¶Remaining Keys: " & _rKeys & 
"¶P start: " & _pstart &
"¶P end: " & _pend &
"¶Left bit: " & _eL &
"¶Right bit: "  & _eR &
"¶Target bit: " & _targetValue &
"¶Value: " & _value &
"¶¶" ; _ ) & */

Case ( // control case split

_control = "delete" ; Case (

  IsEmpty ( _rKeys ) or not _pstart ;  _eL & _eR ;     // reached destination, or can't find it
  ( (_targetType ≠ "list") and (_targetType ≠ "dict") ) ; json.#Escape ( _list ; _level ; _c ) ;    // the next level is not targetable
  _eL  & json.#Escape ( _startKey ; _level ; _c ) & json.|Tool ( _action ; _targetValue ; _level + 1 ; json.Null ; _rKeys ; _c ; json.Null ) & json.#Escape ( ":>" ; _level ; json.Null ) & _eR 
) ;

_control = "insert" ; Case (
  IsEmpty ( _rKeys ) ; _eL & json.#Escape ( _startKey ; _level ; _c ) & json.#Escape ( _value ; _level + 1 ; _c ) & json.#Escape ( ":>" ; _level ; json.Null ) & _eR ;  // update last value
  _eL & json.#Escape ( _startKey ; _level ; _c ) & json.|Tool ( _action ; _targetValue ; _level + 1 ; _value ; _rKeys ; _c ; json.Null ) & json.#Escape ( ":>" ; _level ; json.Null ) & _eR
) 

) // end control case split

) ; // end Let for DICT


// top if, stop querying if not valid
(_vType ≠ "dict") and (_vType ≠ "list") ; Let ( $cf_|Tool_error = "Error 7006: wrong type found at index " & _value ; _eList ) ; 




) // END MASTER CASE 4 SET_...

) // END TOP KEY SETTING LET




)  // END GRAND CASE

/*
 & If (1; Let($$bug_result = $$bug_result &
"¶¶Action: " & _action &
"¶List: " & _list & 
"¶Level: " & _level & 
"¶Value: " & _value &
"¶i: " & _i & 
"¶C: " & _c & 
"¶_e: " & _e &"¶"; _ ) )
 */
