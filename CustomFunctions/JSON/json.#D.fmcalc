/* Handles mixed dicts and lists, objects and arrays or wotever u wish to call them...

Supports Slices

Expecting to be called with variables thus:

#D ( "$var [ key ] { [ ... ] [ key N ] }" )  = this case is unique = it will dynamically reset the variable and return nothing, allowing you to do multiple calls without nesting, making for easy to read code

...with fields to evaluate thus:

#D ( "Field [ key ] { [ ... ] [ key N ] }" )
#D ( "Specified::Field [ key ] { [ ... ] [ key N ] }" )

...with actual lists or dicts thus:
// BUT BEWARE>>>
#D ( localVar & "[ key ] { [ ... ] [ key N ] }" )
#D ( $$global & "[ key ] { [ ... ] [ key N ] }" )
#D ( Field::Name & "[ key ] { [ ... ] [ key N ] }" )
#D ( $ListOrDict & $key )
IN THIS INSTANCE the keys must not contain "|->" or ":>", i.e. lists or dicts, unlikely that they would but you never know
*/

Let ( [

  _vType = json.#VarType ( _name ) ; // so i can quickly know if they've passed a raw dict/list
  _splitPos = Case ( _vType = "list" ; Position ( _name ; "|->" ; Length(_name) ; -1 ) + 2 ; _vType = "dict" ; Position ( _name ; ":>" ; Length(_name) ; -1 ) + 1  ) ;
  _pos1 = Position ( _name ; "[" ; _splitPos ; 1 ) ;  // first bracket
  _emptyWithBrackets = (_pos1=1); // EMPTY DICT/LIST SUPPLIED PROBABLY or poor terming... [name] in either case just strips first brackets
  _splitPos = Case ( _splitPos ; _splitPos ; _pos1 > 1 ; _pos1 - 1 ; 0 ) ;
  _pos2 = Position ( _name ; "]" ; _pos1 ; 1 ) ;

  _List_Dict_REF = Trim (  Left ( _name ; _splitPos )  ) ;  // this will either rip $hello from $hello[key] or <|-list|-> from <|-list|->key or <|-list|->[key]
  _key = Trim ( Right ( _name ; Length(_name)-_splitPos) );
  _key = Case ( Left ( _key ; 1 ) ≠"[" ; _key ; _pos1 and _pos2 ; Trim ( Middle ( _name ; _pos1 + 1 ; _pos2 - _pos1 -1 ) ) &  Trim ( Middle ( _name ; _pos2 + 1 ; Length ( _name ) ) ) ) ;  // guarantees keys are key1[key2] or key1 but never [key1]
  _var = Left ( _List_Dict_REF ; 1 ) = "$" ;
  _brackets_OK = not PatternCount ( _key ; "[" ) or Exact ( PatternCount ( _name ; "[" ) ; PatternCount ( _name ; "]" ) ) // either 0 or matching numbers of []s
];


Case ( _brackets_OK  and not IsEmpty(_key) and not _emptyWithBrackets ; 

Let (
[
$cf_|Tool_error = ""; // this needed! - if the ting breaks don't TOUCH array, return as is, unbroken...? or handle on basis of error number?

_md_array = Case ( (_vType = "list") or (_vType = "dict") ; _List_Dict_REF ; Evaluate (      Case (   _var  ; _List_Dict_REF ; "GetField ( GetFieldName ( " & _List_Dict_REF & " ) )"     )     ) );

/* ERROR behaviour question - could just then set it as a level, e.g. lev0[lev1] - lev0 not field, so make it a two level dict? */
    _md_arrayType = json.#VarType ( _md_array ) ;
    _error = Case (   _md_arrayType = "List" or _md_arrayType = "Dict" or _md_arrayType ="empty" ; json.Null ; _md_array = "?" ; "Field reference did not evaluate (probably - or it could have been a '?' in the target content)." ; "Invalid Target Content Type" );  // UNREPORTED ATM


/* BUG TEST
$$bug_result =  "¶¶_List_Dict_REF: " & _List_Dict_REF & "¶_var: " & _var &  "¶_splitpos: " & _splitPos & "¶_pos1: " & _pos1 & "¶_pos2: " & _pos2 & "¶_md_array: " & _md_array & "¶_key: "& _key & "¶¶" ;  */

_result = If ( Length(_error); _error; json.|Tool ( "SET_delete" ; _md_array ; 0 ; json.Null ; _key ; 0 ; json.Null ) )
]
;

If ( _var ; Evaluate ( "Let ( " & _List_Dict_REF & " = " & Quote ( _result ) & " ; _ )" ) ; _result )
/*--------------
 if it's a _var just set the var, don't return it; else it's a field, *assume* they know wot they are doing and using this in a 'set field' context thus: SetField ( Table::MyArray ; #(  MyArray[one][7][anyKeyWill Do]; "anyvalue will do- brackets ignored here" ) )
----------------*/
) ; // end let

// else invalid syntax so leave untouched
If ( not _var ; _List_Dict_REF)

) // end brackets match if

) // end let

